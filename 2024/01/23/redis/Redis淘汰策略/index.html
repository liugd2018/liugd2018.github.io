<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Redis淘汰策略 | Programming Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis淘汰策略</h1><a id="logo" href="/.">Programming Notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis淘汰策略</h1><div class="post-meta">2024-01-23<span> | </span><span class="category"><a href="/categories/Redis/">Redis</a></span></div><div class="post-content"><h3 id="设置多大的缓存容量合适？"><a href="#设置多大的缓存容量合适？" class="headerlink" title="设置多大的缓存容量合适？"></a>设置多大的缓存容量合适？</h3><p>建议把缓存容量设置为总数据量的 15% 到 30%区间，兼顾访问性能和内存空间开销。</p>
<p>设定缓存的固定大小命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure>

<h3 id="Redis-缓存有哪些淘汰策略？"><a href="#Redis-缓存有哪些淘汰策略？" class="headerlink" title="Redis 缓存有哪些淘汰策略？"></a>Redis 缓存有哪些淘汰策略？</h3><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。我们可以按照是否会进行数据淘汰把它们分成两类：</p>
<ul>
<li>不进行数据淘汰的策略，只有 noeviction 这一种。</li>
<li>会进行淘汰的 7 种其他策略。</li>
</ul>
<p>会进行淘汰的 7 种策略，我们可以再进一步根据淘汰候选数据集的范围把它们分成两类：</p>
<ul>
<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。</li>
<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种。</li>
</ul>
<p><img src="https://liugd-oss.oss-cn-beijing.aliyuncs.com/note-picture/redis/1661323470463.jpg"></p>
<h4 id="noeviction策略"><a href="#noeviction策略" class="headerlink" title="noeviction策略"></a>noeviction策略</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul>
<li>Redis 在使用的内存空间超过 maxmemory 值时，不会淘汰数据</li>
<li>缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误</li>
</ul>
<h4 id="设置过期时间淘汰策略"><a href="#设置过期时间淘汰策略" class="headerlink" title="设置过期时间淘汰策略"></a>设置过期时间淘汰策略</h4><p>volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略，它们筛选的候选数据范围，被限制在已经设置了过期时间的键值对上。也正因为此，即使缓存没有写满，这些数据如果过期了，也会被删除。</p>
<ul>
<li>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。</li>
<li>volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。</li>
</ul>
<h4 id="所有键值淘汰策略"><a href="#所有键值淘汰策略" class="headerlink" title="所有键值淘汰策略"></a>所有键值淘汰策略</h4><p>一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p>
<ul>
<li>allkeys-random 策略，从所有键值对中随机选择并删除数据；</li>
<li>allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。</li>
<li>allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。</li>
</ul>
<h3 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h3><p>LRU 算法的全称是 Least Recently Used，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</p>
<h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><p>LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据。</p>
<p>LRU 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问，所以就把它放在 MRU 端；长久不访问的数据，肯定就不会再被访问了，所以就让它逐渐后移到 LRU 端，在缓存满时，就优先删除它。</p>
<p>LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p>
<h4 id="Redis-LRU算法"><a href="#Redis-LRU算法" class="headerlink" title="Redis LRU算法"></a>Redis LRU算法</h4><p>在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p>
<p>Redis 提供了一个配置参数 maxmemory-samples，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory-samples 100</span><br></pre></td></tr></table></figure>

<p>当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：<strong>能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。</strong>当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。</p>
<p>这样一来，Redis 缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。</p>
<p>使用 LFU 算法以外的 5 种缓存淘汰策略，我再给你三个使用建议。</p>
<ul>
<li>优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。</li>
<li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</li>
<li>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</li>
</ul>
<h3 id="LFU-策略"><a href="#LFU-策略" class="headerlink" title="LFU 策略"></a>LFU 策略</h3><p>LFU 策略中会从两个维度来筛选并淘汰数据：</p>
<ul>
<li>数据访问的时效性（访问时间离当前时间的远近）</li>
<li>数据的被访问次数</li>
</ul>
<p>LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</p>
<p>Redis 在实现 LRU 策略时使用了两个近似方法：</p>
<ul>
<li>Redis 是用 RedisObject 结构来保存数据的，RedisObject 结构中设置了一个 lru 字段，用来记录数据的访问时间戳；<ul>
<li>原来 24bit 大小的 lru 字段，又进一步拆分成了两部分。<ul>
<li>ldt 值：lru 字段的前 16bit，表示数据的访问时间戳；</li>
<li>counter 值：lru 字段的后 8bit，表示数据的访问次数。</li>
</ul>
</li>
</ul>
</li>
<li>Redis 并没有为所有的数据维护一个全局的链表，而是通过随机采样方式，选取一定数量（例如 10 个）的数据放入候选集合，后续在候选集合中根据 lru 字段值的大小进行筛选。</li>
</ul>
<p>总结一下：当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 lru 字段的后 8bit 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 lru 字段的前 16bit 值大小，选择访问时间最久远的数据进行淘汰。</p>
<h4 id="非线性增长的计数器访问次数"><a href="#非线性增长的计数器访问次数" class="headerlink" title="非线性增长的计数器访问次数"></a>非线性增长的计数器访问次数</h4><p>Redis 的counter 值使用了 8bit 记录数据的访问次数，而 8bit 记录的最大值是 255。<strong>在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。</strong></p>
<p>LFU 策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Logarithmically increment a counter. The greater is the current counter value</span></span><br><span class="line"><span class="comment"> * the less likely is that it gets really implemented. Saturate it at 255. */</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Logistic Counter最大值为255  </span></span><br><span class="line">  <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">  <span class="comment">// 取一个0~1的随机数r  </span></span><br><span class="line">  <span class="type">double</span> r = (<span class="type">double</span>)<span class="built_in">rand</span>()/RAND_MAX;</span><br><span class="line">  <span class="comment">// counter减去LFU_INIT_VAL （LFU_INIT_VAL为每个key的Logistic Counter初始值，默认为5）</span></span><br><span class="line">  <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">  <span class="comment">// 如果衰减之后已经小于5了，那么baseval &lt; 0取0</span></span><br><span class="line">  <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// lfu-log-factor在这里被使用</span></span><br><span class="line">  <span class="comment">// 可以看出如果lfu_log_factor的值越大，p越小</span></span><br><span class="line">  <span class="comment">// r &lt; p的概率就越小，Logistic Counter增加的概率就越小（因此lfu_log_factor越大增长越缓慢）</span></span><br><span class="line">  <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过设置不同的 lfu_log_factor 配置项，来控制计数器值增加的速度，避免 counter 值很快就到 255 了。 lfu_log_factor值越大，增速就会越慢。</p>
<p><img src="https://liugd-oss.oss-cn-beijing.aliyuncs.com/note-picture/redis/1661394004837.jpg"></p>
<p>我们在应用 LFU 策略时，一般可以将 lfu_log_factor 取值为 10。</p>
<h4 id="计数器的衰减"><a href="#计数器的衰减" class="headerlink" title="计数器的衰减"></a>计数器的衰减</h4><p>Redis 在实现 LFU 策略时，还设计了一个 counter 值的衰减机制。有些数据在短时间内被大量访问后就不会再被访问了。那么再按照访问次数来筛选的话，这些数据会被留存在缓存中，但不会提升缓存命中率。</p>
<p>LFU 策略使用衰减因子配置项 lfu_decay_time 来控制访问次数的衰减。LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。</p>
<p>简单举个例子，假设 lfu_decay_time 取值为 1，如果数据在 N 分钟内没有被访问，那么它的访问次数就要减 N。如果 lfu_decay_time 取值更大，那么相应的衰减值会变小，衰减效果也会减弱。所以，如果业务应用中有短时高频访问的数据的话，建议把 lfu_decay_time 值设置为 1，这样一来，LFU 策略在它们不再被访问后，会较快地衰减它们的访问次数，尽早把它们从缓存中淘汰出去。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在实际业务应用中，LRU 和 LFU 两个策略都有应用。LRU 和 LFU 两个策略关注的数据访问特征各有侧重，LRU 策略更加关注数据的时效性，而 LFU 策略更加关注数据的访问频次。通常情况下，实际应用的负载具有较好的时间局部性，所以 LRU 策略的应用会更加广泛。但是，在扫描式查询的应用场景中，LFU 策略就可以很好地应对缓存污染问题了，建议你优先使用。</p>
<p>此外，如果业务应用中有短时高频访问的数据，除了 LFU 策略本身会对数据的访问次数进行自动衰减以外，我再给你个小建议：你可以优先使用 volatile-lfu 策略，并根据这些数据的访问时限设置它们的过期时间，以免它们留存在缓存中造成污染。</p>
<h3 id="使用了-LFU-策略后，你觉得缓存还会被污染吗？"><a href="#使用了-LFU-策略后，你觉得缓存还会被污染吗？" class="headerlink" title="使用了 LFU 策略后，你觉得缓存还会被污染吗？"></a>使用了 LFU 策略后，你觉得缓存还会被污染吗？</h3><p>被污染的概率取决于LFU的配置，也就是lfu-log-factor和lfu-decay-time参数。 </p>
<p>1、根据LRU counter计数规则可以得出，counter递增的概率取决于2个因素：</p>
<p> a) counter值越大，递增概率越低</p>
<p> b) lfu-log-factor设置越大，递增概率越低 </p>
<p>所以当访问次数counter越来越大时，或者lfu-log-factor参数配置过大时，counter递增的概率都会越来越低，这种情况下可能会导致一些key虽然访问次数较高，但是counter值却递增困难，进而导致这些访问频次较高的key却优先被淘汰掉了。</p>
<p> 另外由于counter在递增时，有随机数比较的逻辑，这也会存在一定概率导致访问频次低的key的counter反而大于访问频次高的key的counter情况出现。</p>
<p> 2、如果lfu-decay-time配置过大，则counter衰减会变慢，也会导致数据淘汰发生推迟的情况。 </p>
<p>3、另外，由于LRU的ldt字段只采用了16位存储，其精度是分钟级别的，在counter衰减时可能会产生同一分钟内，后访问的key比先访问的key的counter值优先衰减，进而先被淘汰掉的情况。</p>
<p>可见，Redis实现的LFU策略，也是近似的LFU算法。Redis在实现时，权衡了内存使用、性能开销、LFU的正确性，通过复用并拆分lru字段的方式，配合算法策略来实现近似的结果，虽然会有一定概率的偏差，但在内存数据库这种场景下，已经做得足够好了。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/01/23/redis/Redis%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/">Redis并发操作</a><a class="next" href="/2024/01/23/redis/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2/">Redis主从同步与故障切换</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liugd2018.github.io"/></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://liugd2018.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="mailto:liugd2020@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/liugd2018" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LIUNX/">LIUNX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lombok/">lombok</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongoDB/">mongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/openvpn/">openvpn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%80%E5%85%A5java%E6%B7%B1%E4%BC%BC%E6%B5%B7/">一入java深似海</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%8B%E6%B5%8B/">压测</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8/">安卓模拟器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E9%A9%AC%E5%93%A5java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/">小马哥java进阶训练营</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/">数据结构与算法之美</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Elasticsearch/" style="font-size: 15px;">Elasticsearch</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/mac%E5%86%85%E5%BD%95/" style="font-size: 15px;">mac内录</a> <a href="/tags/lombok/" style="font-size: 15px;">lombok</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MYSQL/" style="font-size: 15px;">MYSQL</a> <a href="/tags/MYSQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">MYSQL实战45讲笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/" style="font-size: 15px;">线上问题</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/k8s%E5%8E%8B%E6%B5%8B/" style="font-size: 15px;">k8s压测</a> <a href="/tags/Hyper-V/" style="font-size: 15px;">Hyper-V</a> <a href="/tags/LIUNX/" style="font-size: 15px;">LIUNX</a> <a href="/tags/mongoDB/" style="font-size: 15px;">mongoDB</a> <a href="/tags/openvpn/" style="font-size: 15px;">openvpn</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8/" style="font-size: 15px;">安卓模拟器</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/Containerd/" style="font-size: 15px;">Containerd</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/" style="font-size: 15px;">数据结构与算法之美</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/MYSQL/%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A0%B5%E5%A1%9E/">线上数据库连接数爆满导致堵塞</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%BE%8E/%E7%AE%97%E6%B3%95%E9%A6%96%E9%A1%B5-01/">数据结构和算法分类</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/%E5%AE%B9%E5%99%A8/Docker%E5%9F%BA%E7%A1%80/">Docker基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/%E5%AE%B9%E5%99%A8/Containerd-%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/">Containerd 搭建以及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/byte%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E8%8C%83%E5%9B%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-128~127/">byte一个字节的数据大小范围为什么是-128~127</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8/MAC-%E7%BD%91%E6%98%93mumu%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BF%AE%E6%94%B9hosts/">MAC 网易mumu安卓模拟器修改hosts</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/VM/%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%86%85%E9%83%A8centos%E8%99%9A%E6%8B%9F%E6%9C%BA/">内网访问不到宿主机内部centos虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/TOOL/pierced%EF%BC%9A%E9%92%89%E9%92%89%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">pierced钉钉内网穿透，仅支持80/443端口</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/Spring/SpringCloud/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/23/Spring/SpringCloud/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/">服务注册与发现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Programming Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>